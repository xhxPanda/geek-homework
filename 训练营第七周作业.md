`题目1` 完成 ReadView 案例，解释为什么 RR 和 RC 隔离级别下看到查询结果不一致
      
案例 01- 读已提交 RC 隔离级别下的可见性分析  
目标  
证明RC的可见性是可以获取已经提交的事务。

操作步骤  


实践过程   
<table>
        <tr>
            <th>时间</th>
            <th>事务01</th>
            <th>事务02</th>
            <th>事务03</th>
        </tr>
        <tr>
            <th>T1</th>
            <th>开启事务</th>
            <th>开启事务</th>
            <th>开启事务</th>
        </tr>
        <tr>
            <th>T2</th>
            <th>更新为"充值任务"</th>
            <th>无</th>
            <th>无</th>
        </tr>
        <tr>
            <th>T3</th>
            <th>更新为"杀怪任务"</th>
            <th>无</th>
            <th>无</th>
        </tr>
        <tr>
            <th>T4</th>
            <th></th>
            <th>更新为"副本任务", 卡住</th>
            <th></th>
        </tr>
        <tr>
            <th>T5</th>
            <th></th>
            <th>更新为"免费任务"， 卡住</th>
            <th></th>
        </tr>
        <tr>
            <th>T5</th>
            <th></th>
            <th></th>
            <th>select desc为"任务测试一下"</th>
        </tr>
        <tr>
                    <th>T6</th>
                    <th>提交事务01</th>
                    <th></th>
                    <th></th>
                </tr>
        <tr>
               <th>T7</th>
               <th></th>
               <th></th>
               <th>select desc为"杀怪任务"</th>
        </tr>   
        <tr>
                       <th>T8</th>
                       <th></th>
                       <th>提交事务02</th>
                       <th></th>
                </tr>    
        <tr>
                       <th>T7</th>
                       <th></th>
                       <th></th>
                       <th>select desc为"免费任务"</th>
                </tr>         
    </table>
结论  

案例 02- 可重复读 RR 隔离级别下的可见性分析  
目标  
证明RR的可见性
操作步骤  
实践过程  
<table>
        <tr>
            <th>时间</th>
            <th>事务01</th>
            <th>事务02</th>
            <th>事务03</th>
        </tr>
        <tr>
            <th>T1</th>
            <th>开启事务</th>
            <th>开启事务</th>
            <th>开启事务</th>
        </tr>
        <tr>
            <th>T2</th>
            <th>更新为"充值任务"</th>
            <th>无</th>
            <th>无</th>
        </tr>
        <tr>
            <th>T3</th>
            <th>更新为"杀怪任务"</th>
            <th>无</th>
            <th>无</th>
        </tr>
        <tr>
            <th>T4</th>
            <th></th>
            <th>更新为"副本任务", 卡住</th>
            <th></th>
        </tr>
        <tr>
            <th>T5</th>
            <th></th>
            <th>更新为"免费任务"， 卡住</th>
            <th></th>
        </tr>
        <tr>
            <th>T5</th>
            <th></th>
            <th></th>
            <th>select desc为"111"</th>
        </tr>
        <tr>
                    <th>T6</th>
                    <th>提交事务01</th>
                    <th></th>
                    <th></th>
                </tr>
        <tr>
               <th>T7</th>
               <th></th>
               <th></th>
               <th>select desc为"111"</th>
        </tr>   
        <tr>
                       <th>T8</th>
                       <th></th>
                       <th>提交事务02</th>
                       <th></th>
                </tr>    
        <tr>
                       <th>T9</th>
                       <th></th>
                       <th></th>
                       <th>select desc为"111"</th>
                </tr>     
                 <tr>
                       <th>T10</th>
                       <th></th>
                       <th></th>
                       <th>提交事务</th>
                 </tr> 
        <tr>
                               <th>T10</th>
                               <th></th>
                               <th></th>
                               <th>select desc为"免费任务"</th>
                         </tr>          
    </table>   

结论  
RR隔离级别下，一个事务只会看到事务开启的时候的数据

结论分析  
mysql通过在RC、RR隔离级别查询的时候会生成read view，但是两者的生成时间不一样，RC是在查询语句的时候生成read view，RR是在事务开始的时候生成read view  



`题目2`
什么是索引  
索引是一个数据库提供的一个数据结构，能够提高获取数据的效率，索引是存储在磁盘上的文件中
。索引可以提高数据查询效率，降低数据库IO成本，降低数据排序的成本，但是索引相当于使用空间换时间，磁盘空间会被更多的占用。而且由于更新数据库的同时也需要更新索引的数据，因此数据表使用索引会增加更新数据的效率，一张更新过于频繁的表不建议使用索引。  
按照索引列的数量分类可以分为单列索引和组合索引，单列索引是指索引中只有一个列，组合索引是由2个以上的字段创建的索引。  
索引的原理是，利用利用数据结构实现更高效率的不同类型的数据查询，希望通过索引缩小查询数据的时间，尽可能不占用太多的内存空间和磁盘空间。
通常索引使用的数据结构是B+树，B+树是多叉树，而且所有的数据都存储在叶子结点，叶子节点之间使用双向指针连接。由于B+树每层的节点比较多，但是层数比较少，可以减少磁盘IO次数；B+树除了叶子节点其它节点并不存储数据，磁盘IO一次读出的数据量大小是固定的，每一次的IO查出的数据变小，也能减少IO次数，从而减少IO耗时。而且由于叶子节点是使用双向指针连接起来，可以实现快捷的范围查询。  
索引又可以分为聚簇索引和辅助索引，聚簇索引叶子节点存储的数据，辅助索引叶子节点存储的是主键，在InnoDB中，都是使用B+树作为数据结构。一个数据库表必然存在聚簇索引（如果一个表没有主键，InnoDB会生成隐藏的字段）。而辅助索引每次使用都会查出数据的主键然后利用查出来的主键再查询一次获取得到数据。  

创建索引的原则  
1.表的记录数量比较少不要使用索引  
2.一个表的索引数量不能过多，因为在数据更新的时候也会对索引进行更新，如果表的索引过多，更新表的性能消耗比较高。  
3.无序的列使用索引的效果会比较差，比如使用UUID生成的主键id。   
4.尽量选择区分度高的列作为索引。字段不重复的比例越高，扫描到的记录数量越少。
5.组合索引应该把频繁使用的列，区分度高的值放在前面。

创建索引有几大注意事项，如果不遵守的话有可能会令索引失效：  
1.最左前缀匹配原则，比如索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询，而且当遇到范围查询(>、<、between、like)就会停止匹配。     
2.索引列不能参与计算,否则会索引失效。  
3.Like模糊查询要使用%在右边的索引，才能使索引生效。  
4.尽量使用覆盖索引。  
5.不要使用不等于的判断，不要判断null。
6.字符串类型的字段需要加单引号.  
7.索引字段不要使用或（OR）判断。  

一个sql有无使用到索引进行查询，可以使用explain语句进行分析，看Extra字段有无显示"Using index"，看type字段的信息可以体现出一个sql语句的搜索范围，如果显示All，证明该条查询语句是没有使用索引而且是全表扫描。

`题目3`什么是MVCC  
MVCC叫多版本并发控制，是用来对数据库数据进行并发访问，读不加锁，读写不冲突。使用了数据快照，不同的事务访问不同版本的数据快照。它的实现基于undo日志和Read View。  
Undo log 主要用于记录数据被修改之前的日志，当事务进行回滚时可以通过undo log 里的日志进行数据还原，在表信息修改之前先会把数据拷贝到undo log里。每条undo log都有一个版本的属性，这些undo log日志连起来，就可以形成版本链
。在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。
ReadView是张存储事务id的表，主要包含当前系统中有哪些活跃的读写事务，把它们的事务id放到一个
列表中。一个事务有可能在第一次查询的时候就会生成ReadView，RC隔离级别每次读取数据前都生成一个ReadView，RR隔离级别在事务开启的时候就会生成ReadView，生成的时候就会指定查询的版本链中的版本号，根据版本号实现MVCC。  

