`题目1` 请你说一说Mysql的锁机制
从锁的功能划分有共享锁和排他锁，其实就很像java里面的读写锁，共享锁相
当于读锁，读锁之间不阻塞，写操作会阻塞。排他锁就预示写锁，写锁阻塞其他的操作  
从锁的粒度划分有全局锁（锁整个数据库）、表级锁（锁整个表）、行级锁（锁单行）。这里面最值得说的是行锁  
1.记录锁，锁住记录的一行，记录锁锁住的是索引。表中没有索引InnoDB会创建隐藏字段作为索引。  
2.间隙锁，锁住一个索引的区间，不包括双端。  
3.临键锁，可以理解成一个左开右闭的间隙锁，InnoDb使用临键锁来锁定记录，但是这会存在锁退化。如果where是等值查询，存在记录的话，会退化成记录锁；
不存在记录的情况会退化为间隙锁；如果是范围查询，还是临键锁，如果有多个查询字段，还是临键锁。  
4.插入意向锁，因为InnoDB通过间隙锁、临键锁解决幻读问题，但是这个时候插入的话会导致锁冲突，为了增加数据库的效率，当多个不同的事务，同时往同一个索引的同一个间隙中插入数据的时候，它们互相之间无需等待，即不会阻塞。  

死锁是一组相互竞争资源的事务因为他们之间得到互相等待导致阻塞的现象；  
我遇到死锁之后，会在sentry查看到有deadLock错误，然后是会叫DBA拿到最近的死锁日志，当然课程里面有说是使用SHOW ENGINE INNODB STATUS; 查出什么sql导致了死锁，分析语句的上锁情况。

详细说说这条 SQL 的锁定情况：delete from tt where uid = 666;
RC隔离级别：
1.如果uid被设置为主键的话，上行写锁；锁主键索引
2.如果uid的列加了唯一索引，加记录锁，写锁
3.如果有非唯一索引，把所有符合条件的记录的主键索引都加上记录锁，写锁
4、如果uid没有索引，写锁锁全表

RR隔离级别
1.如果uid被设置为主键的话，上行写锁；锁主键索引
2.如果uid的列加了唯一索引，加记录锁，写锁
3.加uid索引加上间隙锁，在对应的主键索引的记录加上记录锁
4.uid无索引，标上所有数据的主键都加间隙锁。





`题目2` 请你说一说MySQL的SQL优化
其实前段时间我们公司有一个慢查询的统计，我参与到里面的一些语句的修改，我发现：  
1.当一个慢查询没有用到表中任何一个索引，或者表中根本没有索引的话，这个慢查询其实可以通过加索引来解决，我觉得80%的慢查询其实都可以通过索引来解决。  
2.在一个查询里面，查出了大量的数据，会造成慢查询，这个时候需要使用limit缩减查询的数据量。  
在一个有成熟架构的公司来说，基本解决前面2个问题，就可以解决90%的慢查询，当然还可以通过业务来进行优化慢查询，就不多说了在这个题目里。  
3.使用业务尽可能写成单表的查询。  
4.如果业务上不能够使用单表的查询，使用子查询的时候尽量使用通过数据规模小的表去驱动查询数据规模相对较大的表。